{
    "contents" : "library(GenomicRanges)\nlibrary(plyr)\n\nforbidden <- c(\"seqnames\", \"ranges\", \"strand\", \"seqlevels\", \"seqlengths\",\n\t\t\t\t\t\t\t \"isCircular\", \"start\", \"end\", \"width\", \"element\")\n\nroll.haplotypes <- function(haps, seqlengths = seqlengths, seal = FALSE, ...) {\n\t\n\tdlply(haps, .(id), function(d) {\n\t\trez <- dlply(d, .(origin), function(p) {\n\t\t\tseg <- with(p, GRanges(seqnames = Rle(seqnames), seqlengths = seqlengths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t ranges = IRanges(start = start, end = end),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t strain = strain, id = id))\n\t\t\tseg <- sort(seg)\n\t\t\tif (seal)\n\t\t\t\treturn( seal.segments(seg) )\n\t\t\telse\n\t\t\t\treturn(seg)\n\t\t})\n\t\tclass(rez) <- c(\"haplotypes\", class(rez))\n\t\treturn(rez)\n\t}, .progress = \"text\")\n\t\n}\n\nroll.recombinations <- function(haps, seqlengths = seqlengths, ...) {\n\t\n\tdlply(haps, .(id), function(d) {\n\t\trez <- dlply(d, .(origin), function(p) {\n\t\t\tgr <- with(p, GRanges(seqnames = Rle(seqnames), seqlengths = seqlengths,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tranges = IRanges(start = start, end = end),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom = from, to = to, id = id))\n\t\t\tvalues(gr) <- cbind(values(gr), p[ ,setdiff(colnames(p), c(forbidden,colnames(values(gr)))) ])\n\t\t\treturn(gr)\n\t\t})\n\t\t# class(rez) <- c(\"haplotypes\", class(rez))\n\t\treturn(rez)\n\t})\n\t\n}\n\ninvert.recombinations <- function(recombs, seal = FALSE, ...) {\n\t\n\tlapply(recombs, function(r.all) {\n\t\tsegments <- GRanges()\n\t\tfor (c in unique(runValue(seqnames(r.all)))) {\n\t\t\tr <- r.all[ seqnames(r.all) == c ]\n\t\t\tif (seal) {\n\t\t\t\t# 'seal' haplotype segments together -- eg. get rid of uncertainty around recomb events\n\t\t\t\tg <- GRanges(seqnames = c, seqinfo = seqinfo(r),\n\t\t\t\t\t\t\t\t\t\t ranges = IRanges(start = c(1, pmin( mid(ranges(r))+1, seqlengths(r)[c] )),\n\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\t end = c(mid(ranges(r)), seqlengths(r)[c])),\n\t\t\t\t\t\t\t\t\t\t strain = c( as.character(values(r)$from), rev(as.character(values(r)$to))[1] )\n\t\t\t\t)\n\t\t\t\tsegments <- c(segments, g)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (length(r)) {\n\t\t\t\t\tif (length(r) > 1) {\n\t\t\t\t\t\ti <- 1:(length(r)-1)\n\t\t\t\t\t\t# un-overlap possibly overlapping recomb events\n\t\t\t\t\t\tend(r)[i] <- pmin( end(r)[i], start(r)[i+1]-1 )\n\t\t\t\t\t\tstart(r)[i+1] <- pmax( end(r)[i]+2, start(r)[i+1] )\n\t\t\t\t\t}\n\t\t\t\t\tr <- sort(r)\n\t\t\t\t\tg <- gaps(r)\n\t\t\t\t\tg <- g[ strand(g) == \"*\" & (as(seqnames(g), \"character\") %in% as(seqnames(r), \"character\")) ]\n\t\t\t\t\tvalues(g)$strain <- c( as.character(values(r)$from), rev(as.character(values(r)$to))[1] )\n\t\t\t\t\tsegments <- c(segments, g)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t# print(segments)\n\t\treturn(segments)\n\t})\n\t\n}\n\n# overlap.with.meta <- function(query, subject, metavars = colnames(values(query)), ...) {\n# \t\n# \tflag <- (query %over% subject)\n# \tmeta.flag <- matrix(ncol = 0, nrow = length(query))\n# \t\n# \tif (length(subject) > 1 & !(length(subject) == length(query))) {\n# \t\twarning(\"Result will probably not be well-defined due to shape of query vs subject ranges.\")\n# \t}\n# \t\n# \tfor (i in colnames(values(query))) {\n# \t\tif (i %in% colnames(values(subject))) {\n# \t\t\t# hits.this.subject <- sapply(1:length(subject), function(j) flag & (as.character(values(query)[,i]) == as.character(values(subject)[j,i])) )\n# \t\t\t# print(hits.this.subject)\n# \t\t\thits.this.subject <- flag & (values(query)[,i] == values(subject)[,i])\n# \t\t\tmeta.flag <- cbind(meta.flag, hits.this.subject)\n# \t\t}\n# \t}\n# \t\n# \treturn(meta.flag)\n# \t\n# }\n# \n# grep.haplotypes <- function(haps, target, strain.col = \"strain\", ...) {\n# \t\n# \t## how many haplotype segments in <haps> overlap <target>? \n# \t\n# \tstopifnot(length(target) > 0)\n# \t\n# \tllply(haps, function(h) {\n# \t\trez <- lapply(h, function(hh) {\n# \t\t\tsapply(1:length(target), function(t) overlap.with.meta(hh, target[t], metavars = strain.col))\n# \t\t})\n# \t\treturn( sum(sapply(rez, any)) )\n# \t}, .progress = \"text\")\n# \t\n# }\n# \n# grep.recombinations <- function(recombs, target, from = NULL, to = NULL, ...) {\n# \t\n# \tstopifnot(length(target) > 0)\n# \t\n# \tllply(recombs, function(h) {\n# \t\tsapply(h, function(hh) {\n# \t\t\ti <- rep(TRUE, length(hh))\n# \t\t\tif (!is.null(from))\n# \t\t\t\ti <- i & (values(hh)$from == from)\n# \t\t\tif (!is.null(to))\n# \t\t\t\ti <- i | (values(hh)$to == to)\n# \t\t\tcountOverlaps(target, hh[i])\n# \t\t})\n# \t}, .progress = \"text\")\n# \t\n# }\n\noverlap.with.meta <- function(haps, target, haps.flat = NULL, meta.cols = NULL, ...) {\n\t\n\t## given a list-of-lists of rolled haplotypes, find those which overlap <target> AND have same metadata\n\t## (if a flattened haplotypes object is already available, allow it to be passed in to avoid re-flattening)\n\t\n\tall.gr <- GRanges()\n\tif (!is.null(haps.flat))\n\t\tall.gr <- haps.flat\n\telse\n\t\tall.gr <- flatten.haplotypes(haps, \"all\")\n\t\n\tolap <- all.gr %over% target\n\tif (is.null(meta.cols))\n\t\tmeta.cols <- intersect( colnames(values(target)), colnames(values(all.gr)) )\n\tfor (col in meta.cols) {\n\t\tolap <- olap & (values(all.gr)[ ,col ] == values(target)[ ,col ])\n\t}\n\tall.gr$olap <- olap\n\tall.df <- as.data.frame(all.gr)\n\trez <- daply(all.df, .(id, origin), summarize, sum(as.numeric(olap)))\n\t\n\treturn(rez)\n\t\n}\n\ngrep.haplotypes <- function(haps, target, meta.cols = \"strain\", ...) {\n\t\n\t## how many haplotype segments in <haps> overlap <target>? \n\t\n\tstopifnot(length(target) > 0)\n\toverlap.with.meta(haps, target, meta.cols = meta.cols, ...)\n\t\n}\n\ngrep.recombinations <- function(recombs, target, meta.cols = c(\"to\",\"from\"), ...) {\n\t\n\t## how many recombination events in <recombs> overlap <target>? \n\t\n\tstopifnot(length(target) > 0)\n\toverlap.with.meta(recombs, target, meta.cols = meta.cols, ...)\n\t\n}\n\nfind.recombinants <- function(...) {\n\t\n\trez <- grep.recombinations(...)\n\tsapply(rez, sum) > 0\n\t\n}\n\nseal.segments <- function(gr, ...) {\n\t\n\t## \"seal\" haplotype segments by joining them at midpoint of uncertainty interval\n\n\tdf <- as.data.frame(sort(gr))\n\trez <- ddply(df, .(seqnames), function(d) {\n\t\tmids <- floor((d$start[-1] + d$end[ -nrow(d) ])/2)\n\t\td$start[1] <- 1\n\t\td$end[-nrow(d)] <- mids\n\t\td$start[-1] <- mids + 1\n\t\td$end[ nrow(d) ] <- seqlengths(gr)[ d$seqnames[1] ]\n\t\td$width <- NULL # not an allowed column name to makeGRangesFromDataFrame()\n\t\treturn(d)\n\t})\n\t\n\tmakeGRangesFromDataFrame(rez, keep.extra.columns = TRUE, ignore.strand = TRUE)\n\t\n}\n\nflatten.haplotypes <- function(haps, by = c(\"parent\",\"all\"), ...) {\n\t\n\t## flatten the nested-list haplotype structure either into a list of GRanges() (by = \"parent\") or a single GRanges(by = \"all\")\n\t\n\tif (by == \"all\") {\n\t\trez <- ldply(haps, function(h) ldply(h, as.data.frame),\n\t\t\t\t\t\t\t\t .progress = \"text\")\n\t\tif (\"width\" %in% colnames(rez))\n\t\t\trez$width <- NULL\n\t\tmakeGRangesFromDataFrame(rez, keep.extra.columns = TRUE, ignore.strand = TRUE)\n\t}\n\telse if (by == \"parent\") {\n\t\trez <- llply(haps, function(h) {\n\t\t\thh <- ldply(h, as.data.frame)\n\t\t\tif (\"width\" %in% colnames(hh))\n\t\t\t\thh$width <- NULL\n\t\t\tmakeGRangesFromDataFrame(hh, keep.extra.columns = TRUE, ignore.strand = TRUE)\n\t\t}, .progress = \"text\")\n\t\treturn(rez)\n\t}\n\t\n}",
    "created" : 1407887023271.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1121409904",
    "id" : "68238747",
    "lastKnownWriteTime" : 1407887434,
    "path" : "C:/Users/Andrew Parker Morgan/Dropbox/pmdvlab/R_multiparental/R/haptools.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}